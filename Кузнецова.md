## Создать таблицы и задать связи, заполнить данными для следующих примеров:

### 1. Конференции и выступления:
- конференция может иметь несколько выступлений
- выступление может принадлежать только одной конференции
- конференция - название, дата, адрес
- выступление - название, дата, тема

### 2. Задачи и комментарии:
- задача может иметь несколько комментариев
- комментарий может принадлежать только одной задаче
- задача - название, описание, сложность
- комментарий - текст, дата публикации

### 3. Курьеры и заказы:
- курьер может иметь несколько заказов
- заказ может принадлежать только одному курьеру
- курьер - имя, фамилия, телефон
- заказ - адреса, дата, статус

## Для каждого примера сделать вывод связанных сущностей (за один запрос)
- зависимая сущность должна быть представлена в виде массива объектов
- учесть случай когда на главную таблицу может не быть ссылок в строках зависимой таблицы
- если на строки из главной таблицы нет ссылок из зависимой таблицы, эти строки всё равно должны выводиться
- на одну из строк главной таблицы должно быть хотя бы 2 ссылки из зависимой таблицы



tasks:


drop table if exists conference, concert cascade;

create table conference
(
	id int primary key,
	name text,
	data date,
	adress text
);

create table concert
(
	id int primary key,
	conf_id int references conference,
	title text,
	data date,
	theme text
);

insert into conference(id, name, data, adress)
values (1, 'Том', '2020-06-01', 'Нагатинская улица д.6'),
       (2, 'Бенедикт', '2016-07-19', 'Столешников переулок д.1'),
       (3, 'Анастасия', '2023-01-15', 'Воскресенская д.12');
      
insert into concert(id, conf_id, title, data, theme)
values (1, 1, 'стендап', '2020-06-01', 'шуточки'),
       (2, 1, 'Рок день', '2016-07-19', 'музыка'),
       (3, 2, 'джаз', '2016-07-19', 'музыка'),
       (4, 2, 'мизулина', '2016-07-19', 'безопасность'),
       (5, 3, 'пляски', '2016-07-19', 'танцы'),
       (6, 3, 'Шаман', '2023-01-15', 'патриотизм');
      
 
select * from conference;

select * from concert;

-- вывод зависимой сущности в виде массива объектов
select
  conf.id,
  conf.name,
  conf.data,
  conf.adress,
  coalesce(json_agg(json_build_object(
    'id', con.id, 'title', con.title, 'year', con.data, 'theme', con.theme))
      filter (where con.id is not null), '[]')
        as concert
from conference conf
left join concert con on conf.id = con.conf_id
group by conf.id;





drop table if exists tasks, comments cascade;

create table tasks
(
	id int primary key,
	name text,
	about text,
	level int
);

create table comments
(
	id int primary key,
	task_id int references tasks,
	texts text,
	data date
);

insert into tasks(id, name, about, level)
values (1, 'уборка', 'протетреть пыль зеркала полы дверь починить украсить комнату покрмить кота', 7),
       (2, 'еда', 'приготовить окрошку и суп накормить бабушку и сходить в магазин', 6),
       (3, 'доп занятия', 'сходить на танцы побеседовать с педагогом', 4);
      
insert into comments(id, task_id, texts, data)
values (1, 1, 'выполнено', '2020-06-01'),
       (2, 1, 'кот не захотел есть', '2016-07-19'),
       (3, 2, 'бабушки не было дома', '2016-07-19'),
       (4, 2, 'суп прокис', '2016-07-19'),
       (5, 3, 'заболела', '2016-07-19'),
       (6, 3, 'выполнено', '2023-01-15');
      
 
select * from tasks;

select * from comments;

-- вывод зависимой сущности в виде массива объектов
select
  t.id,
  t.name,
  t.about,
  t.level,
  coalesce(json_agg(json_build_object(
    'id', com.id, 'title', com.texts, 'year', com.data))
      filter (where com.id is not null), '[]')
        as comments
from tasks t
left join comments com on t.id = com.conf_id
group by t.id;



drop table if exists delivers, asks cascade;

create table delivers
(
	id int primary key,
	name text,
	sername text,
	phone int
);

create table asks
(
	id int primary key,
	deliv_id int references delivers,
	adress text,
	data date,
	state text
);

insert into delivers(id, name, sername, phone)
values (1, 'Том', 'Журавликов', 890304567890),
       (2, 'Бенедикт', 'Тяпков', 89067894567),
       (3, 'Анастасия', 'Невскова', 85437896756);
      
insert into asks(id, deliv_id, adress, data, state)
values (1, 1, 'Столешников переулок д.9', '2020-06-01', 'выполнено'),
       (2, 1, 'Профсоюзная улица д.85', '2016-07-19', 'выполнено'),
       (3, 2, 'Мякинская д.12', '2016-07-19', 'выполнено с опозданием 15 минут'),
       (4, 2, 'Вскресенская 12 д.1', '2016-07-19', 'заказ холодный'),
       (5, 3, 'Дубковая улца д.7', '2016-07-19', 'выполнено'),
       (6, 3, 'Шаманская аллея 33', '2023-01-15', 'возврат');
      
 
select * from delivers;

select * from asks;

-- вывод зависимой сущности в виде массива объектов
select
  del.id,
  del.name,
  del.data,
  del.adress,
  coalesce(json_agg(json_build_object(
    'id', a.id, 'title', a.title, 'year', a.data))
      filter (where a.id is not null), '[]')
        as asks
from delivers del
left join asks a on del.id = a.deliv_id
group by del.id;
